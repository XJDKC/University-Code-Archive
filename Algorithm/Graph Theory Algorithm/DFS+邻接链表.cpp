/*
DFS 深度优先搜索
基本思想：从一个节点开始出发进行对图中每个节点的访问
		对于初始节点找到一条边 就顺着这条边往下一直找
		直到访问到一个节点其周围没有 还没被访问的节点 或者说 没有通向下一个节点的边（两种情况）
		为止 这个时候就回到上一个节点 沿着上一个节点的其他边继续往下找 循环往复 就可以把所有节点全部访问完全
		也就是搜索到所有的节点
		相比于宽度优先搜索 深度优先搜索在遍历的时候对于一个节点的所有边并不是依次访问完全 
		而是先访问完一条边下所有的路径后 再对其他边进行访问 也就是一条路走到底 直到无路可走
		故为深度优先搜索 
*/
#include<iostream>
#include<algorithm>
using namespace std;
const int N=10005;
struct node				
{
	int no;				//有向边另一端连接节点的编号
	int v;				//该边的边权
	node *next;			//指向i节点连接的下一条边
};
node *g[N];				//指针数组 g[i]表示 i节点周围所有边构成的链表表头

int n;					//节点个数 编号 从0-（n-1）
bool visited[N];		//访问标记
void dfs(int num)
{
	node *p;					
	p=g[num];					//取出num节点周围所有边构成的链表表头

	visited[num]=true;			//将num节点的访问标记置为true 表示num 节点已经被访问过了
	cout<<num<<" ";				//输入访问节点的编号
	while (p)					//循环对每条边进行深搜
	{
		if (!visited[p->no])	//如果这个点没有被访问过
		{
			dfs(p->no);			//递归调用dfs 对该边连接的另一端的点进行深搜
		}
		p=p->next;				//到了这一步 说明p之下能够到达的所有边的所有节点都被访问过了 进入num节点连接的另外一条边的深搜
	}

}
int main()
{
	int m;
	node *p;
	cin>>n>>m;						//输入节点数 和 边数
	for (int i=0,x,y,z;i<m;i++)		//依次输入各边信息
	{
		cin>>x>>y>>z;				//分别表示边的头 尾 边权值 表示一条由x->y的边权为z的有向边
		p=new(node);				//为p分配新的空间
		p->v=z;p->no=y;p->next=g[x];g[x]=p;	//将信息赋值给p  并将p加入g[x]链的链头
	}
	dfs(0);							//从0号节点开始进行深搜
	return 0;
}